---
title: Developers
description: An overview of the three main integration paths for building on Uniswap — smart contracts, SDKs, and the Trading API.
---

Uniswap offers multiple ways to integrate depending on what you're building and where your code runs. Most integrations fall into one of three categories: on-chain smart contracts, client-side SDKs, or the server-side Trading API. You can use them independently or combine them — for example, a dApp frontend might use the SDK for quoting and the Trading API for execution.

## Smart Contracts (On-chain)

If you're building directly on the Ethereum Virtual Machine — custom hooks, novel pool types, on-chain arbitrage, or any logic that needs to execute atomically with a swap — you'll work with the Uniswap protocol contracts directly.

Uniswap v4 introduces a [hook system](/docs/get-started/concepts/hooks) that lets developers attach custom logic to pools at key lifecycle points (swap, add/remove liquidity, donate). This is the most powerful integration path and the one that makes v4 fundamentally different from previous versions.

**Good for:** hooks, custom pools, on-chain integrations, MEV strategies, flash accounting

- [Protocol overview](/docs/protocols/v4/overview)
- [Getting started with hooks](/docs/protocols/v4/guides/hooks/getting-started)

## SDKs (JavaScript/TypeScript)

The Uniswap SDKs provide typed, ergonomic abstractions for interacting with the protocol from JavaScript and TypeScript environments. They handle the complexity of encoding calldata, computing prices, and managing positions so you don't have to work with raw contract ABIs.

Use the SDKs when you're building a frontend, a Node.js service that constructs transactions, or any off-chain system that needs to reason about Uniswap pool state.

**Good for:** dApp frontends, off-chain quoting, position management, building trading interfaces

- [SDK overview](/docs/sdks/v4/overview)
- [Getting started with quoting](/docs/sdks/v4/guides/swapping/quoting)

## Trading API (REST)

The Uniswap Trading API is the simplest integration path. Send an HTTP request, get back a quote or a ready-to-submit transaction. No blockchain node required, no SDK dependency, no Solidity.

The API handles routing across protocol versions and chains, finding the optimal execution path for a given trade. It supports both indicative quotes (for display) and firm quotes (for execution).

**Good for:** backends, trading bots, aggregators, mobile apps, any system that needs swap quotes without running infrastructure

- [API documentation](/docs/api)
- [Getting started with swaps](/docs/api/guides/swapping/getting-started)

## Other Resources

Beyond the three core integration paths, Uniswap provides additional tools for building:

- **Subgraphs** — Query indexed on-chain data (pool state, historical swaps, positions, token metrics) via GraphQL. Useful for analytics, dashboards, and any application that needs historical data rather than current state. See the [subgraph documentation](/docs/resources/subgraphs).

- **Unichain** — Uniswap's purpose-built L2, designed for DeFi with faster block times and lower fees. If you're choosing where to deploy, Unichain is worth evaluating alongside Ethereum mainnet and other supported chains.

## Choosing an Integration Path

| | Smart Contracts | SDKs | Trading API |
|---|---|---|---|
| **Runtime** | On-chain (EVM) | Client or server (JS/TS) | Any (HTTP) |
| **Complexity** | High | Medium | Low |
| **Flexibility** | Full protocol access | Transaction construction | Quoting and routing |
| **Use case** | Hooks, custom pools, atomic operations | dApp frontends, position management | Bots, backends, simple swaps |

Most teams start with the Trading API for basic swap functionality, graduate to the SDKs when they need more control over transaction construction, and reach for smart contracts when they need on-chain composability or custom pool behavior.
